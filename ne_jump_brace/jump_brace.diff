diff -r -c lib.orig/term_inkey.c lib/term_inkey.c
*** lib.orig/term_inkey.c	Sun May 14 21:57:29 2000
--- lib/term_inkey.c	Wed Nov 20 00:55:15 2002
***************
*** 1682,1692 ****
  		 if (*s=='\0')
  		 	break;
  
! 		 if (*s!='[')
  		 	{
! 		 	 k[n]= k[n]==KS_ctrl? *s&0x1f: *s;
! 		 	 ++s;
! 		 	 continue;
  		 	}
  
  		 ++s;
--- 1682,1697 ----
  		 if (*s=='\0')
  		 	break;
  
! 		/*	if *s is not a '[', or a '[' without a ']', consume this character here.
! 
! 			strchr may be called twice if this condition is not met.
! 			this should not cause any problems and I leave it for now.
! 		*/
! 		 if (*s!='[' || strchr(s, ']') == NULL)
  		 	{
! 			 k[n]= k[n]==KS_ctrl? *s&0x1f: *s;
! 			 ++s;
! 			 continue;
  		 	}
  
  		 ++s;
diff -r -c src.orig/function.h src/function.h
*** src.orig/function.h	Wed Apr 26 10:49:18 2000
--- src/function.h	Mon Nov 18 17:13:28 2002
***************
*** 78,84 ****
  SHELL	void	op_search_next();
  SHELL	void	op_search_getword();
  SHELL	void	op_search_paging();
! 
  
    /* file command */
  SHELL	void	op_file_toggle();
--- 78,85 ----
  SHELL	void	op_search_next();
  SHELL	void	op_search_getword();
  SHELL	void	op_search_paging();
! SHELL	void	op_search_brace_prev();
! SHELL	void	op_search_brace_next();
  
    /* file command */
  SHELL	void	op_file_toggle();
diff -r -c src.orig/search.c src/search.c
*** src.orig/search.c	Sun Apr 30 12:54:13 2000
--- src/search.c	Wed Nov 20 00:47:49 2002
***************
*** 356,358 ****
--- 356,572 ----
  //	crt_ledraw();
  }
  
+ 
+ 
+ /*=============================================================================
+ 	search appropriate brace.
+ 
+ 	assuming that brace is a pair of same-width character.
+ 	i.e. narrow brace always matches to narrow opponent, not wide one.
+ */
+ /*-----------------------------------------------------------------------------
+ 	find appropriate pair of braces according to *pchBrace.
+ 	returns each brace and length.
+ */
+ static	size_t	find_brace_opponent(const char* pchCursor, const char** ppchBrace, const char** ppchOpponent)
+ {
+ 	static	const char*	vpszBraces[ ] = {
+ 		/* 0 byte  */	NULL,
+ 		/* 1 byte  */	"()<>[]{}",
+ 		/* 2 bytes */	"(**)/**/¡Æ¡Ç¡È¡É¡Ê¡Ë¡Ì¡Í¡Î¡Ï¡Ð¡Ñ¡Ò¡Ó¡Ô¡Õ¡Ö¡×¡Ø¡Ù¡Ú¡Û",
+ 	} ;
+ 
+ 	size_t	cbBrace ;
+ 
+ 
+ 	for (cbBrace = sizeof vpszBraces / sizeof *vpszBraces ; 0 < cbBrace ; --cbBrace) {
+ 		int			ich ;
+ 		const char*	pszBraces ;
+ 
+ 		pszBraces = vpszBraces[ cbBrace ] ;
+ 		for (ich = 0 ; pszBraces[ ich ] != '\0' ; ich = kanji_posnext(ich, pszBraces)) {
+ 			if (strncmp(pszBraces + ich, pchCursor, cbBrace) == 0) {
+ 				/*	braces are assumed to be always a pair.
+ 					so that a pair occupies (cbBraces * 2) bytes.
+ 					when we found the *pchBrace on (cbBraces * 2) boundary,
+ 					pchBrace point to open brace, its opponent is a close brace.
+ 					otherwise, the opponent is an open brace.
+ 				*/
+ 				*ppchBrace = &pszBraces[ ich ] ;
+ 				if (ich % (cbBrace * 2) == 0)
+ 					*ppchOpponent = *ppchBrace + cbBrace ;
+ 				else
+ 					*ppchOpponent = *ppchBrace - cbBrace ;
+ 
+ 				return cbBrace ;
+ 				/* NOTREACHED */
+ 			}
+ 		}
+ 	}
+ 
+ 	/* no appropriate opponent has been found. */
+ 	return cbBrace ;
+ }
+ 
+ 
+ /*-----------------------------------------------------------------------------
+ 	search appropriate brace or letter for top of file.
+ */
+ SHELL	void	op_search_brace_prev()
+ {
+ 	size_t		cbBrace ;	/* 1 for narrow, 2 for wide, ...	*/
+ 	const char*	pszBrace ;	/* a brace */
+ 	const char*	pszPair  ;	/* and its pair */
+ 
+ 	int			ich ;
+ 
+ 	EditLine*	pLine ;	/* line buffer in iLine-th Line */
+ 	long		iLine ;	/* line number */
+ 	int			iTail ;	/* where search ends in pLine->buffer */
+ 	int			cNest ;	/* nesting levels of braces */
+ 
+ 	bool	b_found ;
+ 
+ 
+ 	/*	find the appropriate pair of brace under the cursor.
+ 		return if nothing seems to be appropriate.
+ 	*/
+ 	cbBrace = find_brace_opponent(csrle.buf + csrle.lx, &pszBrace, &pszPair) ;
+ 	if (cbBrace == 0)
+ 		return ;
+ 		/* NOTREACHED */
+ 
+ 	/*	now we try to find anything in the search buffer(i.e. pair of braces) */
+ 	csr_leupdate();
+ 	system_msg(SEARCHING_MSG);
+ 
+ 	cNest = 0 ;
+ 	b_found = FALSE ;
+ 	iLine = GetLineOffset( ) ;
+ 	pLine = GetList( iLine ) ;
+ 	iTail = GetBufferOffset( ) + cbBrace ;
+ 
+ 	do {
+ 		/*	scoreboard.
+ 
+ 			checking an characters one by one from tail to head is an
+ 			expensive job in MBCS environment.
+ 			i.e. an character would be composed of 2 or more bytes.
+ 			here we 'scoreboard' each character from head to tail and
+ 			see if we got match by utilizing the scoreboard.
+ 
+ 			this scoreboard holds
+ 				1  for character same as pszBrace
+ 				-1 for character same as pszPair
+ 				0  for otherwise
+ 			if 1 < cbBrace case(i.e. we're searching for MBCS brace pair),
+ 			-1 and 1 are held for its first byte only.
+ 
+ 			Although we could use calloc here safely,
+ 			original author tend to use mem_alloc instead of malloc and etc.
+ 			we'll belong to the author.
+ 			Or we can define the scoreboard as an array.
+ 			(MAXLINESTR is defined as 2048,
+ 			 which seems to be a little huge for me to be on a stack.)
+ 
+ 			iTail + 1 avoids mem_alloc(0) when the line is empty.
+ 		*/
+ 		char*	pch_sb = mem_alloc( iTail + 1 ) ;
+ 		memset(pch_sb, 0, iTail + 1) ;
+ 
+ 		/*	see if braces we're searching for are in the pLine->buffer.
+ 			if we see any of them, remember where and what it is.
+ 		*/
+ 		for (ich = 0 ; ich < iTail ; ich = kanji_posnext(ich, pLine->buffer))
+ 			if (memcmp(pLine->buffer + ich, pszBrace, cbBrace) == 0)
+ 				pch_sb[ ich ] = 1 ;
+ 			else if (memcmp(pLine->buffer + ich, pszPair, cbBrace) == 0)
+ 				pch_sb[ ich ] = -1 ;
+ 
+ 		/*	now we have scoreboard in pchsb.
+ 			see if we'll got to nest level 0 in backward.
+ 		*/
+ 		for (ich = iTail - 1 ; 0 <= ich ; --ich) {
+ 			cNest += pch_sb[ ich ] ;
+ 			if (pch_sb[ ich ] == -1 && cNest == 0)
+ 				break ;
+ 				/* NOTREACHED */
+ 		}
+ 
+ 		/* free scoreboard */
+ 		free( pch_sb ) ;
+ 
+ 		if (0 <= ich) {
+ 			cursor_move(ich, iLine) ;
+ 			return ;
+ 			/* NOTERACHED */
+ 		}
+ 
+ 		--iLine ;
+ 		pLine = pLine->prev ;
+ 		if ( pLine->buffer )
+ 			iTail = strlen( pLine->buffer ) ;
+ 	} while (0 < iLine && pLine != NULL && pLine->buffer != NULL) ;
+ 
+ 	system_msg(NOT_FOUND_MSG);
+ }
+ 
+ 
+ 
+ /*-----------------------------------------------------------------------------
+ 	search appropriate brace or letter for end of file.
+ */
+ SHELL	void	op_search_brace_next()
+ {
+ 	size_t		cbBrace ;
+ 	const char*	pszBrace ;
+ 	const char*	pszPair ;
+ 
+ 	int		ich ;
+ 
+ 	EditLine*	pLine ;	/* line buffer in iLine-th Line */
+ 	long		iLine ;	/* line number */
+ 	int			iHead ;	/* where search begins in pLine->buffer */
+ 	int			cNest ;	/* nesting levels of braces */
+ 
+ 
+ 	/*	find the appropriate pair of brace under the cursor.
+ 		return if nothing seems to be appropriate.
+ 	*/
+ 	cbBrace = find_brace_opponent(csrle.buf + csrle.lx, &pszBrace, &pszPair) ;
+ 	if (cbBrace == 0)
+ 		return ;
+ 		/* NOTREACHED */
+ 
+ 	csr_leupdate();
+ 	system_msg(SEARCHING_MSG);
+ 
+ 	/*	unlike to op_search_brace_prev case,
+ 		we can see the pLine->buffer from head to tail,
+ 		we don't need scoreboard this time.
+ 	*/
+ 	cNest = 0 ;
+ 	iLine = GetLineOffset( ) ;
+ 	pLine = GetList( iLine ) ;
+ 	iHead = GetBufferOffset( ) ;
+ 
+ 	do {
+ 		for (ich = iHead ; pLine->buffer[ ich ] != '\0' ; ich = kanji_posnext(ich, pLine->buffer)) {
+ 			if (memcmp(pLine->buffer + ich, pszBrace, cbBrace) == 0)
+ 				++cNest ;
+ 			else if (memcmp(pLine->buffer + ich, pszPair, cbBrace) == 0) {
+ 				if (--cNest == 0) {
+ 					cursor_move(ich, iLine) ;
+ 					return ;
+ 					/* NOTREACHED */
+ 				}
+ 			}
+ 		}
+ 
+ 		++iLine ;
+ 		pLine = pLine->next ;
+ 		iHead = 0 ;
+ 	} while (pLine != NULL && pLine->buffer != NULL) ;
+ 
+ 	system_msg(NOT_FOUND_MSG);
+ }
diff -r -c src.orig/setopt.c src/setopt.c
*** src.orig/setopt.c	Sun Apr 30 12:56:24 2000
--- src/setopt.c	Wed Nov 20 00:36:16 2002
***************
*** 132,138 ****
  		 keyf_set(0, "^L",            "search_getword");
  		 keyf_set(0, "[F05]",         "search_getword");
  
! 
  
  		 keyf_set(0, "^_",            "misc_kmacro");
  		 keyf_set(0, "^V",            "opt_set OverWrite");
--- 132,139 ----
  		 keyf_set(0, "^L",            "search_getword");
  		 keyf_set(0, "[F05]",         "search_getword");
  
! 		 keyf_set(0, "^Q[",           "search_brace_prev");
! 		 keyf_set(0, "^Q]",           "search_brace_next");
  
  		 keyf_set(0, "^_",            "misc_kmacro");
  		 keyf_set(0, "^V",            "opt_set OverWrite");
